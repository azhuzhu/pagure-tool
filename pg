#!/usr/bin/python

import click
import dateutil.parser
import os
import pdb
import pprint
import pygit2
import re
import requests
import subprocess
import sys
import time
import traceback
import urllib
import urlparse

BASEURL = 'https://pagure.io'


def pcall(path, query=None, api=0, baseurl=BASEURL):
    url = "%s/api/%s/%s" % (baseurl, api, path)
    if isinstance(query, basestring):
        url = "%s?%s" % (url, query)
    elif query is not None:
        query = urllib.urlencode(query, True)
        url = "%s?%s" % (url, query)
    print "DEBUG: %s" % url
    r = requests.get(url)
    try:
        data = r.json()
    except Exception:
        print "Server returned bad value"
        print r
        raise
    if 'error_code' in data:
        s = "%(error_code)s: %(error)s" % data
        raise Exception(s)
    return data


@click.group()
def pg():
    # main command
    pass


@pg.group()
def pr():
    pass


def get_project(cwd=None):
    if cwd is None:
        cwd = os.getcwd()
    try:
        path = pygit2.discover_repository(cwd)
    except KeyError:
        return None
    repo = pygit2.Repository(path)
    remote = pick_pagure_remote(repo)
    if remote is None:
        return None
    try:
        info = parse_pagure_url(remote.url)
    except ValueError:
        return None
    return info.project


def pick_pagure_remote(repo):
    choices = {}
    for remote in repo.remotes:
        url = remote.url
        if 'pagure.io' in url:  # XXX should be smarter
            choices[remote.name] = remote
    if 'origin' in choices:
        return choices['origin']
    elif choices:
        return choices.values()[0]
    else:
        return None


def parse_pagure_url(url):
    """Parse a pagure git url"""
    info = urlparse.urlparse(url)
    parts = info.path.split('/')
    parts = [p for p in parts if p]
    if parts[0] == 'forks':
        info.parent = parts[1]
        parts = parts[2:]
    if len(parts) > 1:
        info.namespace = parts[0]
        parts = parts[1:]
    if len(parts) > 1:
        raise ValueError('Too many url path components: %s' % url)
    project = parts[0]
    if project.endswith('.git'):
        project = project[:-4]
    info.project = project
    return info


@pr.command('info')
@click.argument('prid')
@click.option('-p', '--project')
@click.option('--json/--no-json')
def prinfo(prid, project, **opts):
    if project is None:
        project = get_project()
        if project is None:
            raise Exception('Please specify a project')
    pr = pcall("%s/pull-request/%s" % (project, prid))
    if opts['json']:
        pprint.pprint(pr)
        return

    print "PR#%(id)i: %(title)s" % pr
    print "https://pagure.io/koji/pull-request/%(id)i" % pr
    print "Status: %(status)s" % pr
    print "User: %s" % pr['user']['name']
    print "Created: %s" % time.asctime(time.localtime(float(pr['date_created'])))
    print "Updated: %s" % time.asctime(time.localtime(float(pr['updated_on'])))
    if pr.get('repo_from'):
        # should we use fullname field?
        print "Fork: %s/%s" % (BASEURL, pr['repo_from']['fullname'])
    elif pr.get('remote_git'):
        print "Remote: %(remote_git)s" % pr
    else:
        print "Can't determine repo?"
        sys.exit(1)
    print "%(branch_from)s -> %(branch)s" % pr
    if pr['status'] != 'Open':
        print '...'

    print
    print "Description:"
    print pr['initial_comment']

    for comment in pr['comments']:
        print
        cts = float(comment['date_created'])
        comment['_username'] = comment['user']['name']
        comment['_tstr'] = time.asctime(time.localtime(float(cts)))
        print "Comment by %(_username)s on %(_tstr)s:" % comment
        print
        print comment['comment']
        print



@pr.command('checkout')
@click.argument('prid')
def pr_checkout(prid, **opts):
    project = get_project()
    if project is None:
        raise Exception('Must be run from pagure checkout')
    pr = pcall("%s/pull-request/%s" % (project, prid))
    url, remote_branch = get_pr_source(pr)

    cwd = os.getcwd()
    path = pygit2.discover_repository(cwd)
    repo = pygit2.Repository(path)

    # current version of pygit2 doesn't seem to be able to fetch from
    # arbitrary urls
    cmd = ['git', 'fetch', url, remote_branch]
    subprocess.check_call(cmd)
    branch = "pagure/pr/%s" % prid
    local_brs = repo.listall_branches(pygit2.GIT_BRANCH_LOCAL)
    if branch in local_brs:
        print "Reusing branch: %s" % branch
        cmd = ['git', 'update-ref',
                '-m', 'pg: updating branch %s' % branch,
                'refs/heads/%s' % branch, 'FETCH_HEAD']
        subprocess.check_call(cmd)
    else:
        obj = repo.get(pr['commit_stop'])
        for br in local_brs:
            bref = repo.lookup_branch(br)
            if bref.target == obj.oid:
                branch = br
                print "Reusing local branch: %s" % branch
                break
        else:
            # make our own
            cmd = ['git', 'branch', branch, 'FETCH_HEAD']
            subprocess.check_call(cmd)
            print "New branch: %s" % branch

    # not sure I trust pygit2's checkout function
    cmd = ['git', 'checkout', branch]
    subprocess.check_call(cmd)
    # TODO: --follow option ?


@pr.command('merge')
@click.option('--force/--no-force', '-f/')
@click.option('--rebase/--no-rebase', '-r/')
def pr_merge(**opts):
    project = get_project()
    if project is None:
        raise Exception('Must be run from pagure checkout')

    cwd = os.getcwd()
    path = pygit2.discover_repository(cwd)
    repo = pygit2.Repository(path)

    # determine pr from branch
    if not repo.head.name.startswith('refs/heads/'):
        raise Exception("HEAD is not a branch")
    branch = repo.head.name[11:]
    prid = get_pr_from_branch(project, repo, branch)
    print "PR branch for %s" % prid

    pr = pcall("%s/pull-request/%s" % (project, prid))
    url, remote_branch = get_pr_source(pr)

    # fetch for comparison
    cmd = ['git', 'fetch', url, remote_branch]
    subprocess.check_call(cmd)

    # pygit2 can't give me FETCH_HEAD
    cmd = ['git', 'rev-parse', 'FETCH_HEAD']
    remote_ref = subprocess.check_output(cmd).strip()
    remote_obj = repo.get(remote_ref)

    if remote_obj.oid != repo.head.target:
        print("Warning: current branch does match remote")
        # TODO: show differences
        if opts['rebase']:
            # for safety, we will not rebase a modified branch
            Exception("Auto-rebase not safe on modified branch")
        if not opts['force']:
            raise Exception('Use --force to merge a modified PR branch')

    # get target branch
    target_branch = pr['branch']

    if opts['rebase']:
        cmd = ['git', 'fetch', 'origin']
        subprocess.check_call(cmd)
        cmd = ['git', 'rebase', 'origin/%s' % target_branch]
        subprocess.check_call(cmd)

    # checkout our target branch
    cmd = ['git', 'checkout', target_branch]
    subprocess.check_call(cmd)

    # TODO: this should probably be an option
    cmd = ['git', 'pull', '--ff-only']
    subprocess.check_call(cmd)

    # generate standard commit message
    pr = pcall("%s/pull-request/%s" % (project, prid))
    msg = (
            "PR#%(id)i: %(title)s\n"
            "\n"
            "Merges #%(id)i\n"
            "https://pagure.io/koji/pull-request/%(id)i\n"
            ) % pr
    parts = [msg]

    # issues
    fixes, relates = get_pr_issues(project, pr)
    if fixes or relates:
        parts.append(
                "# The issues below were derived from the pull request\n"
                "# Please verify their accuracy before committing\n"
                )
    else:
        parts.append('# (no referenced issues found)\n')

    def issuetext(info):
        lines = ["%(_verb)s: #%(id)s"]
        if info['_verb'] != 'Fixes':
            lines.append("# Fixes: #%(id)s")
        lines.extend([
                "%(_url)s",
                "%(title)s",
                "# Status: %(status)s",
                "",
                ])
        return '\n'.join(lines) % issue

    for issue in fixes:
        issue['_url'] = issue_url(pr['project'], issue)
        issue['_verb'] = 'Fixes'
        parts.append(issuetext(issue))
    for issue in relates:
        issue['_url'] = issue_url(pr['project'], issue)
        issue['_verb'] = 'Relates'
        parts.append(issuetext(issue))
    msg = '\n'.join(parts)

    # finally, do the merge
    cmd = ['git', 'merge', '--edit', '-m', msg, '--no-ff', branch]
    subprocess.check_call(cmd)


def issue_url(project, pr):
    ppath = project_path(project)
    return "%s/%s/issue/%s" % (BASEURL, ppath, pr['id'])


def get_pr_from_branch(project, repo, branch):
    if branch.startswith('pagure/pr/'):
        return branch[10:]
    # check to see if a PR head matches repo.head.target
    data = pcall('%s/pull-requests' % project)
    matches = []
    for pr in data['requests']:
        url, pr_branch = get_pr_source(pr)
        if pr_branch != branch:
            continue
        print "Branch name match: %(id)s" % pr
        obj = repo.get(pr['commit_stop'])
        if not obj:
            continue
        print "We have the ref"
        # XXX presuming repo.head matches branch
        if obj.oid != repo.head.target:
            print "branch does not match PR"
            print "pr: %s" % obj.oid
            print "us: %s" % repo.head.target
            continue
        matches.append(pr)
    if not matches:
        raise Exception("Not a pr branch: %s" % branch)
    elif len(matches) > 1:
        raise Exception("Branch matches multiple PRs")
    # else
    pr = matches[0]
    return pr['id']


def get_pr_source(prinfo):
    """Returns a pair [url, branch]"""
    branch = prinfo['branch_from']
    if prinfo.get('repo_from'):
        # apparently, for this we can use the fullname
        url = "https://pagure.io/%(fullname)s.git" % prinfo['repo_from']
    elif prinfo.get('remote_git'):
        url = prinfo['remote_git']
    else:
        raise RuntimeError("Can't determine pr source")
    return url, branch


ISSUE_BRANCH_RE = re.compile(r'issue[_-]?(\d+)', re.I)

ISSUE_FIX_RE = re.compile(
            r'''(?:.*\s+)?                      # junk at beginning
                (?:fixe?[sd]?|close?[sd]?)      # verb
                :?\s*                           # optional separation
                (?:https?://.*/(\w+)/issue/)?   # optional url
                [#]?(\d+)                       # issue number
            ''', re.X|re.I)

ISSUE_RELATE_RE = re.compile(
            r'''(?:.*\s+)?                      # junk at beginning
                (?:relate[sd]?)                 # verb
                :?\s*                           # optional separation
                (?:https?://.*/(\w+)/issue/)?   # optional url
                [#]?(\d+)                       # issue number
            ''', re.X|re.I)


def get_pr_issues(project, prinfo):
    """Return issues that seem to be related to the pr"""
    fixes = []
    relates = []

    # check branch
    branch = prinfo['branch_from']
    m = ISSUE_BRANCH_RE.match(branch)
    if m:
        fixes.append(m.group(1))

    comments = ([prinfo['initial_comment'] or '']
                + [c['comment'] for c in prinfo['comments']])
    for text in comments:
        for line in text.splitlines():
            m = ISSUE_FIX_RE.match(line)
            if m:
                if m.group(1) and m.group(1) != prinfo['project']['name']:
                    # XXX
                    print "cross project issue: %s" % line
                else:
                    fixes.append(m.group(2))
            m = ISSUE_RELATE_RE.match(line)
            if m:
                if m.group(1) and m.group(1) != prinfo['project']['name']:
                    # XXX
                    print "cross project issue: %s" % line
                else:
                    relates.append(m.group(2))

    fixes = set(fixes)
    relates = set(relates) - fixes

    issues = {}
    for issueid in fixes.union(relates):
        try:
            data = pcall("%s/issue/%s" % (project, issueid))
        except Exception:
            data = None
        issues[issueid] = data

    fixes = [issues[n] for n in fixes if issues[n]]
    relates = [issues[n] for n in relates if issues[n]]
    return fixes, relates


# XXX test command
@pr.command('issues')
@click.argument('prid')
@click.option('-p', '--project')
def pr_issues(prid, project, **opts):
    if project is None:
        project = get_project()
        if project is None:
            raise Exception('Please specify a project')
    pr = pcall("%s/pull-request/%s" % (project, prid))
    issues = get_pr_issues(project, pr)
    pprint.pprint(issues)


@pr.command('list')
@click.option('-p', '--project')
@click.option('-o', '--order', default='utime')
def pr_list(project, order):
    if project is None:
        project = get_project()
        if project is None:
            raise Exception('Please project a project')
    data = pcall('%s/pull-requests' % project)
    # count = data['total_requests']
    prs = data['requests']
    for pr in prs:
        ts = int(pr['updated_on'])
        for comment in pr.get('comments', []):
            cts1 = int(comment['date_created'] or 0)
            cts2 = int(comment['edited_on'] or 0)
            ts = max(ts, cts1, cts2)
        pr['utime'] = ts

    if order:
        o_keys = order.split(',')
        def sortkey(pr):
            return [pr.get(k) for k in o_keys]
        prs.sort(key=sortkey)
    for pr in prs:
        print "PR#%(id)i: %(title)s [%(status)s]" % pr


@pr.command('recent')
@click.option('-p', '--project')
@click.option('-s', '--since', default="-7")
def pr_recent(project, since):
    if project is None:
        project = get_project()
        if project is None:
            raise Exception('Please project a project')
    data = pcall('%s/pull-requests' % project)
    prs = data['requests']
    for pr in prs:
        ts = int(pr['updated_on'])
        for comment in pr.get('comments', []):
            cts1 = int(comment['date_created'] or 0)
            cts2 = int(comment['edited_on'] or 0)
            ts = max(ts, cts1, cts2)
        pr['utime'] = ts

    cutoff = get_cutoff_ts(since)
    prs.sort(key=lambda p: p['utime'])
    for pr in prs:
        if pr['utime'] < cutoff:
            continue
        print "-------------------"
        print "PR#%(id)i: %(title)s [%(status)s]" % pr
        print "https://pagure.io/koji/pull-request/%(id)i" % pr
        print "Status: %(status)s" % pr
        print "User: %s" % pr['user']['name']
        if int(pr['date_created']) > cutoff:
            print "Created: %s" % time.asctime(time.localtime(float(pr['date_created'])))
            if pr.get('repo_from'):
                # should we use fullname field?
                print "Fork: %s/%s" % (BASEURL, pr['repo_from']['fullname'])
            elif pr.get('remote_git'):
                print "Remote: %(remote_git)s" % pr
            else:
                print "Can't determine repo?"
                sys.exit(1)
            print "%(branch_from)s -> %(branch)s" % pr
            print
            print "Description:"
            print pr['initial_comment']
        elif int(pr['updated_on']) > cutoff:
            print "Updated: %s" % time.asctime(time.localtime(float(pr['updated_on'])))
        for comment in pr['comments']:
            cts = float(comment['date_created'])
            if cts < cutoff:
                continue
            comment['_username'] = comment['user']['name']
            comment['_tstr'] = time.asctime(time.localtime(float(cts)))
            print "Comment by %(_username)s on %(_tstr)s:" % comment
            print
            print
            print comment['comment']
            print


def get_cutoff_ts(since):
    now = time.time()
    try:
        _since = int(since)
        if _since < 0:
            return now + (_since * 3600 * 24)
        else:
            return since
    except ValueError:
        pass
    return dateutil.parser.parse(since)


def project_path(project):
    parts = []
    if project.get('parent'):
        parts.append('fork')
        parts.append(project['user']['name'])
    if project.get('namespace'):
        parts.append(project.get('namespace'))
    parts.append(project['name'])
    return '/'.join(parts)


@pg.command(name='list-projects')
@click.argument('pattern')
@click.option('--fork/--no-fork', default=False)
def list_projects(pattern, **opts):
    if pattern:
        opts['pattern'] = pattern
    data = pcall('projects', opts)
    # count = data['total_projects']
    for proj in data['projects']:
        proj['_path'] = project_path(proj)
        print "%(_path)s: %(description)s" % proj


@pg.group()
def project():
    pass


@project.command('git-urls')
@click.option('-p', '--project')
def git_urls(project):
    if project is None:
        project = get_project()
        if project is None:
            raise Exception('Please project a project')
    data = pcall("%s/git/urls" % project)
    for url in data['urls']:  # not a list for some reason
        print "%s: %s" % (url, data['urls'][url])


@project.command('git-tags')
@click.option('-p', '--project')
def git_tags(project):
    if project is None:
        project = get_project()
        if project is None:
            raise Exception('Please project a project')
    data = pcall("%s/git/tags" % project)
    for tag in data['tags']:
        print tag


@project.command('git-branches')
@click.option('-p', '--project')
def git_branches(project):
    if project is None:
        project = get_project()
        if project is None:
            raise Exception('Please project a project')
    data = pcall("%s/git/branches" % project)
    for br in data['branches']:
        print br


@project.command()
@click.option('-p', '--project')
def watchers(project):
    if project is None:
        project = get_project()
        if project is None:
            raise Exception('Please project a project')
    data = pcall("%s/watchers" % project)
    for row in data['watchers']:  # dict, not list
        wtype = data['watchers'][row]
        print "%s: %s" % (row, wtype)


@project.command("info")
@click.option('-p', '--project')
def projectinfo(project):
    if project is None:
        project = get_project()
        if project is None:
            raise Exception('Please project a project')
    data = pcall(project)
    pprint.pprint(data)


@pg.group()
def issue():
    pass


def invert_opt(val):
    if val is None:
        return None
    return not val


@issue.command(name='list')
@click.option('-p', '--project')
@click.option('-o', '--order', default='updated_on')
@click.option('--status', help="filter by status")
@click.option('--tags', help="filter by tags")
@click.option('--author', help="filter by author")
@click.option('--assignee', help="filter by assignee")
@click.option('--priority', help="filter by priority")
@click.option('--since', help="filter by date")
@click.option('-m', '--milestones', help="filter by milestone", multiple=True)
@click.option('--stones/--no-stones', help="issues with no milestone")
def issuelist(project, order, **opts):
    if project is None:
        project = get_project()
        if project is None:
            raise Exception('Please project a project')
    opts['no_stones'] = invert_opt(opts['stones'])
    del opts['stones']
    for k in list(opts):
        if opts[k] is None:
            del opts[k]
    if 'since' in opts:
        val = opts['since']
        dt = dateutil.parser.parse(val)
        opts['since'] = int(time.mktime(dt.timetuple()))
    data = pcall("%s/issues" % project, opts)
    issues = data['issues']
    if order:
        o_keys = order.split(',')
        def sortkey(row):
            return [row.get(k) for k in o_keys]
        issues.sort(key=sortkey)
    for row in data['issues']:
        print "%(id)s: %(title)s" % row


@issue.command('recent')
@click.option('-p', '--project')
@click.option('-s', '--since', default="-7")
def issue_recent(project, since):
    if project is None:
        project = get_project()
        if project is None:
            raise Exception('Please project a project')
    # not sure if I trust the api's since filter
    data = pcall("%s/issues" % project)
    issues = data['issues']
    for issue in issues:
        ts1 = int(issue['date_created'] or 0)
        ts2 = int(issue['last_updated'] or 0)
        ts = max(ts1, ts2)
        for comment in issue.get('comments', []):
            cts1 = int(comment['date_created'] or 0)
            cts2 = int(comment['edited_on'] or 0)
            ts = max(ts, cts1, cts2)
        issue['utime'] = ts

    cutoff = get_cutoff_ts(since)
    issues.sort(key=lambda p: p['utime'])
    for issue in issues:
        if issue['utime'] < cutoff:
            continue
        print "-------------------"
        print "Issue#%(id)i: %(title)s [%(status)s]" % issue
        print "https://pagure.io/koji/issue/%(id)i" % issue
        print "User: %s" % issue['user']['name']
        if int(issue['date_created']) > cutoff:
            print "Created: %s" % time.asctime(time.localtime(float(issue['date_created'])))
            print
            print issue['content']
        elif int(issue['last_updated']) > cutoff:
            print "Updated: %s" % time.asctime(time.localtime(float(issue['last_updated'])))
        for comment in issue['comments']:
            cts = float(comment['date_created'])
            if cts < cutoff:
                continue
            comment['_username'] = comment['user']['name']
            comment['_tstr'] = time.asctime(time.localtime(float(cts)))
            print "Comment by %(_username)s on %(_tstr)s:" % comment
            print
            print
            print comment['comment']
            print


@issue.command("info")
@click.argument('issueid')
@click.option('-p', '--project')
def issueinfo(issueid, project):
    if project is None:
        project = get_project()
        if project is None:
            raise Exception('Please project a project')
    data = pcall("%s/issue/%s" % (project, issueid))
    pprint.pprint(data)


if __name__ == '__main__':
    try:
        pg()
    except Exception:
        etype, e, tb = sys.exc_info()
        traceback.print_exc()
        pdb.post_mortem(tb)
